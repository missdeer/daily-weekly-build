commit 4a3c581dae3b46f8200a81cc1a5eecb3db4f42e8
Author: Fan Yang <missdeer@gmail.com>
Date:   Thu Apr 17 20:56:27 2025 +0800

    add AVX512 branches

diff --git a/scintilla/include/VectorISA.h b/scintilla/include/VectorISA.h
index 2369fc24..c0f748a0 100644
--- a/scintilla/include/VectorISA.h
+++ b/scintilla/include/VectorISA.h
@@ -41,7 +41,7 @@
 	// Clang and GCC use -march=x86-64-v3, https://clang.llvm.org/docs/UsersManual.html#x86
 	// MSVC use /arch:AVX2
 	#if defined(_WIN64) 
-		#if defined(__AVX512__) && defined(__AVX512F__) && defined(__AVX512BW__)
+		#if defined(__AVX512__) || (defined(__AVX512F__) && defined(__AVX512BW__))
 			#define NP2_USE_AVX512	1
 		#elif defined(__AVX2__)
 			#define NP2_USE_AVX2	1
diff --git a/src/Helpers.cpp b/src/Helpers.cpp
index 1833b5f2..7a042402 100644
--- a/src/Helpers.cpp
+++ b/src/Helpers.cpp
@@ -628,12 +628,49 @@ bool BitmapAlphaBlend(HBITMAP hbmp, COLORREF crDest, BYTE alpha) noexcept {
 	BITMAP bmp;
 	if (GetObject(hbmp, sizeof(BITMAP), &bmp)) {
 		if (bmp.bmBitsPixel == 32) {
-			//StopWatch watch;
-			//watch.Start();
-			//FILE *fp = fopen("bitmap.dat", "wb");
-			//fwrite(bmp.bmBits, 1, bmp.bmHeight*bmp.bmWidth*4, fp);
-			//fclose(fp);
-#if NP2_USE_AVX2
+#if NP2_USE_AVX512
+			#define BitmapAlphaBlend_Tag    "avx512 4x1"
+			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 4;
+			__m128i *prgba = static_cast<__m128i *>(bmp.bmBits);
+
+			// Convert background color to proper format
+			const __m128i back_color = rgba_to_bgra_epi16_sse4_si32(crDest);
+			const __m512i i16x32Back = _mm512_broadcast_i32x4(back_color);
+			
+			// Prepare alpha blend constants
+			const __m512i i16x32Alpha = _mm512_set1_epi16(static_cast<int16_t>(alpha));
+			const __m512i i16x32_255 = _mm512_set1_epi16(255);
+			const __m512i i16x32_0x8081 = _mm512_set1_epi16(-32639); // 0x8081
+
+			for (ULONG x = 0; x < count; x++) {
+				// Load 128-bit data and promote to 256-bit
+				__m128i src = _mm_load_si128(prgba);
+				__m256i src256 = _mm256_cvtepu8_epi32(src);
+				
+				// Convert to 512-bit and perform blending
+				__m512i expanded = _mm512_cvtepu32_epi64(src256);
+				
+				// Perform alpha blending
+				expanded = _mm512_mullo_epi16(expanded, i16x32Alpha);
+				expanded = _mm512_srli_epi16(
+					_mm512_mulhi_epu16(expanded, i16x32_0x8081), 7);
+				
+				// Add background color contribution
+				__m512i bg_contrib = _mm512_mullo_epi16(i16x32Back, 
+					_mm512_sub_epi16(i16x32_255, i16x32Alpha));
+				bg_contrib = _mm512_srli_epi16(
+					_mm512_mulhi_epu16(bg_contrib, i16x32_0x8081), 7);
+				expanded = _mm512_add_epi16(expanded, bg_contrib);
+				
+				// Pack result back to 128-bit
+				__m256i result256 = _mm512_extracti64x4_epi64(expanded, 0);
+				__m128i result128 = _mm256_castsi256_si128(result256);
+				__m128i result = _mm_cvtepi32_epi8(result128);
+				_mm_store_si128((__m128i*)prgba++, result);
+			}
+
+			return true;
+#elif NP2_USE_AVX2
 #if 1
 			#define BitmapAlphaBlend_Tag	"avx2 4x1"
 			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 4;
@@ -770,7 +807,9 @@ bool BitmapGrayScale(HBITMAP hbmp) noexcept {
 				i16x32Color = _mm512_andnot_si512(_mm512_set1_epi32(0x00ffffff), i16x32Color);
 				i16x32Gray = _mm512_or_si512(i16x32Gray, i16x32Color);
 
-				_mm256_storeu_si256(prgba, _mm512_cvtepi32_epi8(i16x32Gray));
+				__m256i result256 = _mm512_extracti64x4_epi64(i16x32Gray, 0);
+				__m128i result = _mm_cvtepi32_epi8(_mm256_castsi256_si128(result256));
+				_mm256_storeu_si256(prgba, _mm256_inserti128_si256(_mm256_setzero_si256(), result, 0));  // Zero-extend to 256-bit
 			}
 			return true;
 
@@ -839,32 +878,56 @@ bool BitmapGrayScale(HBITMAP hbmp) noexcept {
 // Check if two colors can be distinguished
 //
 bool VerifyContrast(COLORREF cr1, COLORREF cr2) noexcept {
-#if NP2_USE_AVX2
-	__m128i i32x4Fore = unpack_color_epi32_sse4_si32(cr1);
-	__m128i i32x4Back = unpack_color_epi32_sse4_si32(cr2);
+#if NP2_USE_AVX512
+    // Convert single color to 512-bit vector by broadcasting
+    __m128i color1 = _mm_cvtsi32_si128(cr1);
+    __m128i color2 = _mm_cvtsi32_si128(cr2);
+    __m512i i32x16Fore = _mm512_broadcast_i32x4(color1);
+    __m512i i32x16Back = _mm512_broadcast_i32x4(color2);
+
+    __m512i diff = _mm512_sad_epu8(i32x16Fore, i32x16Back);
+    // Sum up the differences using horizontal add
+    int value = _mm512_reduce_add_epi32(diff);
+    if (value >= 400) {
+        return true;
+    }
+
+    // Create weight vectors for RGB components (16 x 32-bit integers)
+    __m512i weights1 = _mm512_set_epi32(0,0,0,0, 0,0,0,0, 0,0,0,0, 3,5,1,0);
+    __m512i weights2 = _mm512_set_epi32(0,0,0,0, 0,0,0,0, 0,0,0,0, 3,6,1,0);
+    
+    i32x16Fore = _mm512_mullo_epi32(i32x16Fore, weights1);
+    i32x16Back = _mm512_mullo_epi32(i32x16Back, weights2);
+    diff = _mm512_sub_epi32(i32x16Fore, i32x16Back);
+    value = _mm512_reduce_add_epi32(diff);
+    return abs(value) >= 400;
 
-	__m128i diff = _mm_sad_epu8(i32x4Fore, i32x4Back);
-	int value = mm_hadd_epi32_si32(diff);
-	if (value >= 400) {
-		return true;
-	}
+#elif NP2_USE_AVX2
+    __m128i i32x4Fore = unpack_color_epi32_sse4_si32(cr1);
+    __m128i i32x4Back = unpack_color_epi32_sse4_si32(cr2);
+
+    __m128i diff = _mm_sad_epu8(i32x4Fore, i32x4Back);
+    int value = mm_hadd_epi32_si32(diff);
+    if (value >= 400) {
+        return true;
+    }
 
-	i32x4Fore = _mm_mullo_epi16(i32x4Fore, _mm_setr_epi32(3, 5, 1, 0));
-	i32x4Back = _mm_mullo_epi16(i32x4Back, _mm_setr_epi32(3, 6, 1, 0));
-	diff = _mm_sub_epi32(i32x4Fore, i32x4Back);
-	value = mm_hadd_epi32_si32(diff);
-	return abs(value) >= 400;
+    i32x4Fore = _mm_mullo_epi16(i32x4Fore, _mm_setr_epi32(3, 5, 1, 0));
+    i32x4Back = _mm_mullo_epi16(i32x4Back, _mm_setr_epi32(3, 6, 1, 0));
+    diff = _mm_sub_epi32(i32x4Fore, i32x4Back);
+    value = mm_hadd_epi32_si32(diff);
+    return abs(value) >= 400;
 
 #else
-	const BYTE r1 = GetRValue(cr1);
-	const BYTE g1 = GetGValue(cr1);
-	const BYTE b1 = GetBValue(cr1);
-	const BYTE r2 = GetRValue(cr2);
-	const BYTE g2 = GetGValue(cr2);
-	const BYTE b2 = GetBValue(cr2);
-
-	return	((abs((3 * r1 + 5 * g1 + 1 * b1) - (3 * r2 + 6 * g2 + 1 * b2))) >= 400) ||
-			((abs(r1 - r2) + abs(b1 - b2) + abs(g1 - g2)) >= 400);
+    const BYTE r1 = GetRValue(cr1);
+    const BYTE g1 = GetGValue(cr1);
+    const BYTE b1 = GetBValue(cr1);
+    const BYTE r2 = GetRValue(cr2);
+    const BYTE g2 = GetGValue(cr2);
+    const BYTE b2 = GetBValue(cr2);
+
+    return  ((abs((3 * r1 + 5 * g1 + 1 * b1) - (3 * r2 + 6 * g2 + 1 * b2))) >= 400) ||
+            ((abs(r1 - r2) + abs(b1 - b2) + abs(g1 - g2)) >= 400);
 #endif
 }
 

commit afb4f1c15711ead6fd10e3b1b0bfdb4783a473ba
Author: Fan Yang <missdeer@gmail.com>
Date:   Thu Apr 17 14:50:50 2025 +0800

    add AVX2 & AVX512 branches

diff --git a/src/Helpers.cpp b/src/Helpers.cpp
index d4cefbb9..1833b5f2 100644
--- a/src/Helpers.cpp
+++ b/src/Helpers.cpp
@@ -734,32 +734,100 @@ bool BitmapGrayScale(HBITMAP hbmp) noexcept {
 	BITMAP bmp;
 	if (GetObject(hbmp, sizeof(BITMAP), &bmp)) {
 		if (bmp.bmBitsPixel == 32) {
+#if NP2_USE_AVX512
 			#define BitmapGrayScale_Tag    "avx512 8x1"
 			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 8;
 			__m256i *prgba = static_cast<__m256i *>(bmp.bmBits);
 
-			const __m512i scale_r = _mm512_set1_epi16(77);
-			const __m512i scale_g = _mm512_set1_epi16(151);
-			const __m512i scale_b = _mm512_set1_epi16(28);
-			
+			const __m512i i16x32_38 = _mm512_set1_epi16(38);
+			const __m512i i16x32_75 = _mm512_set1_epi16(75);
+			const __m512i i16x32_15 = _mm512_set1_epi16(15);
+			const __m512i i16x32_0x80 = _mm512_set1_epi16(0x80);
+			const __m512i i16x32_0xD0 = _mm512_set1_epi16(0xD0);
+
 			for (ULONG x = 0; x < count; x++, prgba++) {
-				const __m512i pixels = _mm512_cvtepu8_epi16(*prgba);
-				const __m512i r = _mm512_mullo_epi16(_mm512_srli_epi16(pixels, 16), scale_r);
-				const __m512i g = _mm512_mullo_epi16(_mm512_srli_epi16(_mm512_slli_epi16(pixels, 8), 16), scale_g);
-				const __m512i b = _mm512_mullo_epi16(_mm512_srli_epi16(_mm512_slli_epi16(pixels, 16), 16), scale_b);
-				
-				__m512i gray = _mm512_add_epi16(_mm512_add_epi16(r, g), b);
-				gray = _mm512_srli_epi16(gray, 8);
-				gray = _mm512_or_si512(gray, _mm512_slli_epi16(gray, 8));
-				gray = _mm512_or_si512(gray, _mm512_slli_epi16(gray, 8));
-				
-				const __m512i alpha = _mm512_and_si512(pixels, _mm512_set1_epi32(0xff000000));
-				gray = _mm512_or_si512(gray, alpha);
-				
-				_mm256_storeu_si256(prgba, _mm512_cvtepi16_epi8(gray));
+				__m512i i16x32Color = unpack_color_epi16_avx512_ptr256(prgba);
+				__m512i i16x32Red = _mm512_srli_epi16(i16x32Color, 16);
+				__m512i i16x32Green = _mm512_srli_epi16(_mm512_slli_epi16(i16x32Color, 8), 16);
+				__m512i i16x32Blue = _mm512_srli_epi16(_mm512_slli_epi16(i16x32Color, 16), 16);
+
+				i16x32Red = _mm512_mullo_epi16(i16x32Red, i16x32_38);
+				i16x32Green = _mm512_mullo_epi16(i16x32Green, i16x32_75);
+				i16x32Blue = _mm512_mullo_epi16(i16x32Blue, i16x32_15);
+
+				__m512i i16x32Gray = _mm512_add_epi16(i16x32Red, i16x32Green);
+				i16x32Gray = _mm512_add_epi16(i16x32Gray, i16x32Blue);
+				i16x32Gray = _mm512_srli_epi16(i16x32Gray, 7);
+
+				i16x32Gray = _mm512_mullo_epi16(i16x32Gray, i16x32_0x80);
+				__m512i i16x32Temp = _mm512_mullo_epi16(_mm512_xor_si512(i16x32_0x80, _mm512_set1_epi16(255)), i16x32_0xD0);
+				i16x32Gray = _mm512_add_epi16(i16x32Gray, i16x32Temp);
+				i16x32Gray = _mm512_srli_epi16(i16x32Gray, 8);
+
+				i16x32Gray = _mm512_or_si512(i16x32Gray, _mm512_slli_epi16(i16x32Gray, 8));
+				i16x32Gray = _mm512_or_si512(i16x32Gray, _mm512_slli_epi16(i16x32Gray, 8));
+				i16x32Gray = _mm512_and_si512(i16x32Gray, _mm512_set1_epi32(0x00ffffff));
+				i16x32Color = _mm512_andnot_si512(_mm512_set1_epi32(0x00ffffff), i16x32Color);
+				i16x32Gray = _mm512_or_si512(i16x32Gray, i16x32Color);
+
+				_mm256_storeu_si256(prgba, _mm512_cvtepi32_epi8(i16x32Gray));
 			}
+			return true;
+
+#elif NP2_USE_AVX2
+			#define BitmapGrayScale_Tag    "avx2 4x1"
+			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 4;
+			__m128i *prgba = static_cast<__m128i *>(bmp.bmBits);
+
+			const __m256i i16x16_38 = _mm256_set1_epi16(38);
+			const __m256i i16x16_75 = _mm256_set1_epi16(75);
+			const __m256i i16x16_15 = _mm256_set1_epi16(15);
+			const __m256i i16x16_0x80 = _mm256_set1_epi16(0x80);
+			const __m256i i16x16_0xD0 = _mm256_set1_epi16(0xD0);
 
+			for (ULONG x = 0; x < count; x++, prgba++) {
+				__m256i i16x16Color = _mm256_cvtepu8_epi16(_mm_loadu_si128(prgba));
+				__m256i i16x16Red = _mm256_srli_epi16(i16x16Color, 16);
+				__m256i i16x16Green = _mm256_srli_epi16(_mm256_slli_epi16(i16x16Color, 8), 16);
+				__m256i i16x16Blue = _mm256_srli_epi16(_mm256_slli_epi16(i16x16Color, 16), 16);
+
+				i16x16Red = _mm256_mullo_epi16(i16x16Red, i16x16_38);
+				i16x16Green = _mm256_mullo_epi16(i16x16Green, i16x16_75);
+				i16x16Blue = _mm256_mullo_epi16(i16x16Blue, i16x16_15);
+
+				__m256i i16x16Gray = _mm256_add_epi16(i16x16Red, i16x16Green);
+				i16x16Gray = _mm256_add_epi16(i16x16Gray, i16x16Blue);
+				i16x16Gray = _mm256_srli_epi16(i16x16Gray, 7);
+
+				i16x16Gray = _mm256_mullo_epi16(i16x16Gray, i16x16_0x80);
+				__m256i i16x16Temp = _mm256_mullo_epi16(_mm256_xor_si256(i16x16_0x80, _mm256_set1_epi16(255)), i16x16_0xD0);
+				i16x16Gray = _mm256_add_epi16(i16x16Gray, i16x16Temp);
+				i16x16Gray = _mm256_srli_epi16(i16x16Gray, 8);
+
+				i16x16Gray = _mm256_or_si256(i16x16Gray, _mm256_slli_epi16(i16x16Gray, 8));
+				i16x16Gray = _mm256_or_si256(i16x16Gray, _mm256_slli_epi16(i16x16Gray, 8));
+				i16x16Gray = _mm256_and_si256(i16x16Gray, _mm256_set1_epi32(0x00ffffff));
+				i16x16Color = _mm256_andnot_si256(_mm256_set1_epi32(0x00ffffff), i16x16Color);
+				i16x16Gray = _mm256_or_si256(i16x16Gray, i16x16Color);
+
+				i16x16Gray = _mm256_packus_epi16(i16x16Gray, i16x16Gray);
+				i16x16Gray = _mm256_permute4x64_epi64(i16x16Gray, 8);
+				_mm_storeu_si128(prgba, _mm256_castsi256_si128(i16x16Gray));
+			}
 			return true;
+
+#else
+			const ULONG count = bmp.bmHeight * bmp.bmWidth;
+			RGBQUAD *prgba = static_cast<RGBQUAD *>(bmp.bmBits);
+
+			for (ULONG x = 0; x < count; x++) {
+				// gray = 0.299*red + 0.587*green + 0.114*blue
+				BYTE gray = (prgba[x].rgbRed * 38 + prgba[x].rgbGreen * 75 + prgba[x].rgbBlue * 15) >> 7;
+				gray = ((gray * 0x80) + (0xD0 * (255 ^ 0x80))) >> 8;
+				prgba[x].rgbRed = prgba[x].rgbGreen = prgba[x].rgbBlue = gray;
+			}
+			return true;
+#endif
 		}
 	}
 	return false;

commit f6515724780259da2db872a0291e7d64654089c9
Author: Fan Yang <missdeer@gmail.com>
Date:   Thu Apr 17 14:39:16 2025 +0800

    check AVX512 enabled options

diff --git a/scintilla/include/VectorISA.h b/scintilla/include/VectorISA.h
index 22e01c07..2369fc24 100644
--- a/scintilla/include/VectorISA.h
+++ b/scintilla/include/VectorISA.h
@@ -41,7 +41,7 @@
 	// Clang and GCC use -march=x86-64-v3, https://clang.llvm.org/docs/UsersManual.html#x86
 	// MSVC use /arch:AVX2
 	#if defined(_WIN64) 
-		#if defined(__AVX512__) || defined(__AVX512F__) || defined(__AVX512BW__)
+		#if defined(__AVX512__) && defined(__AVX512F__) && defined(__AVX512BW__)
 			#define NP2_USE_AVX512	1
 		#elif defined(__AVX2__)
 			#define NP2_USE_AVX2	1

commit 89733dfc60adb93109894aa0b636229970fc1332
Author: Fan Yang <missdeer@gmail.com>
Date:   Thu Apr 17 14:30:26 2025 +0800

    fix AVX2 build

diff --git a/scintilla/include/GraphicUtils.h b/scintilla/include/GraphicUtils.h
index c04320a6..06d2ac2e 100644
--- a/scintilla/include/GraphicUtils.h
+++ b/scintilla/include/GraphicUtils.h
@@ -190,6 +190,41 @@ inline uint32_t bgr_from_bgra_epi32_sse2_si32(__m128i i32x4) noexcept {
 #endif // NP2_USE_SSE2
 
 #if NP2_USE_AVX2 || NP2_USE_AVX512
+// Add SSE4.1 functions that are still used by AVX2 code
+inline __m128i unpack_color_epi16_sse4_si32(uint32_t color) noexcept {
+	return _mm_cvtepu8_epi16(_mm_cvtsi32_si128(color));
+}
+
+inline __m128i unpack_color_epi16_sse4_ptr32(const uint32_t *color) noexcept {
+	return _mm_cvtepu8_epi16(*(reinterpret_cast<const __m128i *>(color)));
+}
+
+inline __m128i unpack_color_epi16_sse4_ptr64(const uint64_t *color) noexcept {
+	return _mm_cvtepu8_epi16(*(reinterpret_cast<const __m128i *>(color)));
+}
+
+inline __m128i unpack_color_epi32_sse4_si32(uint32_t color) noexcept {
+	return _mm_cvtepu8_epi32(_mm_cvtsi32_si128(color));
+}
+
+inline __m128i rgba_to_abgr_epi16_sse4_si32(uint32_t color) noexcept {
+	return unpack_color_epi16_sse4_si32(bswap32(color));
+}
+
+inline __m128i rgba_to_abgr_epi32_sse4_si32(uint32_t color) noexcept {
+	return unpack_color_epi32_sse4_si32(bswap32(color));
+}
+
+inline __m128i rgba_to_bgra_epi16_sse4_si32(uint32_t color) noexcept {
+	const __m128i i16x4 = unpack_color_epi16_sse4_si32(color);
+	return _mm_shufflelo_epi16(i16x4, _MM_SHUFFLE(3, 0, 1, 2));
+}
+
+inline __m128i rgba_to_bgra_epi16x8_sse4_si32(uint32_t color) noexcept {
+	const __m128i i16x4 = unpack_color_epi16_sse4_si32(color);
+	return _mm_broadcastq_epi64(_mm_shufflelo_epi16(i16x4, _MM_SHUFFLE(3, 0, 1, 2)));
+}
+
 #define pshufb_1to2(n)	((-0x8000) | (n))
 #define pshufb_1to4(n)	(0x80808000 | (n))
 
diff --git a/src/Helpers.cpp b/src/Helpers.cpp
index 54a78c1c..d4cefbb9 100644
--- a/src/Helpers.cpp
+++ b/src/Helpers.cpp
@@ -553,17 +553,18 @@ bool BitmapMergeAlpha(HBITMAP hbmp, COLORREF crDest) noexcept {
 			//StopWatch watch;
 			//watch.Start();
 #if NP2_USE_AVX512
-			#define BitmapMergeAlpha_Tag	"avx512 2x1"
-			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 2;
-			uint64_t *prgba = static_cast<uint64_t *>(bmp.bmBits);
+			#define BitmapMergeAlpha_Tag	"avx512 8x1"
+			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 8;
+			__m256i *prgba = static_cast<__m256i *>(bmp.bmBits);
 
-			const __m128i i16x8Back = rgba_to_bgra_epi16x8_avx512_si32(crDest);
+			const __m512i i16x32Back = _mm512_broadcastq_epi64(rgba_to_bgra_epi16_sse2_si32(crDest));
 			for (ULONG x = 0; x < count; x++, prgba++) {
-				__m128i i16x8Fore = unpack_color_epi16_avx512_ptr64(prgba);
-				const __m128i i16x8Alpha = _mm_shufflehi_epi16(_mm_shufflelo_epi16(i16x8Fore, 0xff), 0xff);
-				i16x8Fore = mm_alpha_blend_epi16(i16x8Fore, i16x8Back, i16x8Alpha);
-				const uint64_t color = pack_color_epi16_sse2_si64(i16x8Fore);
-				*prgba = color | UINT64_C(0xff000000ff000000);
+				const __m256i pixels = _mm256_loadu_si256(prgba);
+				__m512i i16x32Fore = _mm512_cvtepu8_epi16(pixels);
+				const __m512i i16x32Alpha = _mm512_shufflelo_epi16(i16x32Fore, 0xff);
+				i16x32Fore = mm512_alpha_blend_epi16(i16x32Fore, i16x32Back, i16x32Alpha);
+				const __m256i result = _mm512_cvtepi16_epi8(i16x32Fore);
+				_mm256_storeu_si256(prgba, _mm256_or_si256(result, _mm256_set1_epi32(0xff000000)));
 			}
 #elif NP2_USE_AVX2
 			#define BitmapMergeAlpha_Tag	"sse4 2x1"
@@ -733,15 +734,31 @@ bool BitmapGrayScale(HBITMAP hbmp) noexcept {
 	BITMAP bmp;
 	if (GetObject(hbmp, sizeof(BITMAP), &bmp)) {
 		if (bmp.bmBitsPixel == 32) {
-			const ULONG count = bmp.bmHeight * bmp.bmWidth;
-			RGBQUAD *prgba = static_cast<RGBQUAD *>(bmp.bmBits);
-
-			for (ULONG x = 0; x < count; x++) {
-				// gray = 0.299*red + 0.587*green + 0.114*blue
-				BYTE gray = (prgba[x].rgbRed * 38 + prgba[x].rgbGreen * 75 + prgba[x].rgbBlue * 15) >> 7;
-				gray = ((gray * 0x80) + (0xD0 * (255 ^ 0x80))) >> 8;
-				prgba[x].rgbRed = prgba[x].rgbGreen = prgba[x].rgbBlue = gray;
+			#define BitmapGrayScale_Tag    "avx512 8x1"
+			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 8;
+			__m256i *prgba = static_cast<__m256i *>(bmp.bmBits);
+
+			const __m512i scale_r = _mm512_set1_epi16(77);
+			const __m512i scale_g = _mm512_set1_epi16(151);
+			const __m512i scale_b = _mm512_set1_epi16(28);
+			
+			for (ULONG x = 0; x < count; x++, prgba++) {
+				const __m512i pixels = _mm512_cvtepu8_epi16(*prgba);
+				const __m512i r = _mm512_mullo_epi16(_mm512_srli_epi16(pixels, 16), scale_r);
+				const __m512i g = _mm512_mullo_epi16(_mm512_srli_epi16(_mm512_slli_epi16(pixels, 8), 16), scale_g);
+				const __m512i b = _mm512_mullo_epi16(_mm512_srli_epi16(_mm512_slli_epi16(pixels, 16), 16), scale_b);
+				
+				__m512i gray = _mm512_add_epi16(_mm512_add_epi16(r, g), b);
+				gray = _mm512_srli_epi16(gray, 8);
+				gray = _mm512_or_si512(gray, _mm512_slli_epi16(gray, 8));
+				gray = _mm512_or_si512(gray, _mm512_slli_epi16(gray, 8));
+				
+				const __m512i alpha = _mm512_and_si512(pixels, _mm512_set1_epi32(0xff000000));
+				gray = _mm512_or_si512(gray, alpha);
+				
+				_mm256_storeu_si256(prgba, _mm512_cvtepi16_epi8(gray));
 			}
+
 			return true;
 		}
 	}

commit 4f93d1d91396f3b50bd18eba0c227351655f870e
Author: Fan Yang <missdeer@gmail.com>
Date:   Thu Apr 17 14:13:01 2025 +0800

    revert AVX2 implementation

diff --git a/src/Helpers.cpp b/src/Helpers.cpp
index d97deaaa..54a78c1c 100644
--- a/src/Helpers.cpp
+++ b/src/Helpers.cpp
@@ -566,18 +566,19 @@ bool BitmapMergeAlpha(HBITMAP hbmp, COLORREF crDest) noexcept {
 				*prgba = color | UINT64_C(0xff000000ff000000);
 			}
 #elif NP2_USE_AVX2
-			#define BitmapMergeAlpha_Tag	"avx2 2x1"
+			#define BitmapMergeAlpha_Tag	"sse4 2x1"
 			const ULONG count = (bmp.bmHeight * bmp.bmWidth) / 2;
 			uint64_t *prgba = static_cast<uint64_t *>(bmp.bmBits);
 
-			const __m128i i16x8Back = rgba_to_bgra_epi16x8_avx2_si32(crDest);
+			const __m128i i16x8Back = rgba_to_bgra_epi16x8_sse4_si32(crDest);
 			for (ULONG x = 0; x < count; x++, prgba++) {
-				__m128i i16x8Fore = unpack_color_epi16_avx2_ptr64(prgba);
+				__m128i i16x8Fore = unpack_color_epi16_sse4_ptr64(prgba);
 				const __m128i i16x8Alpha = _mm_shufflehi_epi16(_mm_shufflelo_epi16(i16x8Fore, 0xff), 0xff);
 				i16x8Fore = mm_alpha_blend_epi16(i16x8Fore, i16x8Back, i16x8Alpha);
 				const uint64_t color = pack_color_epi16_sse2_si64(i16x8Fore);
 				*prgba = color | UINT64_C(0xff000000ff000000);
 			}
+
 #elif NP2_USE_SSE2
 			#define BitmapMergeAlpha_Tag	"sse2 1x1"
 			const ULONG count = bmp.bmHeight * bmp.bmWidth;
